"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hijack = void 0;
var nanoid_1 = require("nanoid");
var Hijack = function (config) {
    if (config.onJsonParseError && typeof config.onJsonParseError !== 'function') {
        throw new TypeError('"onJsonParseError" must be a function!');
    }
    // @ts-ignore
    var middleware = Middleware(config);
    return middleware;
};
exports.Hijack = Hijack;
var Middleware = function (config) { return function (req, res, next) {
    var defWrite = res.write;
    var defEnd = res.end;
    var chunks = [];
    var uniqKeyHijack = '__multi_hijack_' + nanoid_1.nanoid();
    var nextFn = next;
    res.write = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        chunks.push(Buffer.from(args[0]));
        return defWrite.apply(res, [args[0], args[1], args[2]]);
    };
    res.end = function () {
        // if (args[0] && chunks.length > 0) {
        //   chunks = [] // reset
        // }
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args[0]) {
            chunks.push(Buffer.from(args[0]));
        }
        var body = Buffer.concat(chunks).toString('utf8');
        var responseBody = body;
        if (config.json) {
            try {
                responseBody = JSON.parse(body);
            }
            catch (err) {
                if (config.onJsonParseError) {
                    config.onJsonParseError(err);
                }
            }
        }
        if (!req[uniqKeyHijack]) {
            req[uniqKeyHijack] = true;
            // if not return any value from function
            // or not calling response inside the function
            // will continue to the original end (defEnd)
            var isOverride = config.handler(responseBody, req, res, next);
            if (!isOverride) {
                defEnd.apply(res, [args[0], args[1], args[2]]);
            }
        }
        else {
            defEnd.apply(res, [args[0], args[1], args[2]]);
        }
    };
    return nextFn();
}; };
